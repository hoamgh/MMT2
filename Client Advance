import socket
import json
import os
import logging
import threading
import sys

# Setup basic logging
logging.basicConfig(level=logging.INFO)

# Client Configuration
HOST = '127.0.0.1'
PORT = 65433
BUFFER_SIZE = 4096

# Speed multipliers for different priorities
SPEED_MULTIPLIERS = {
    'CRITICAL': 10,
    'HIGH': 4,
    'NORMAL': 1
}

def get_last_position():
    """Retrieve the last position from the file."""
    try:
        if os.path.exists('last_position.txt'):
            with open('last_position.txt', 'r') as f:
                position = f.read()
                return int(position) if position else 0
        return 0
    except Exception as e:
        logging.error("Error reading last_position.txt: %s", e)
        return 0

def set_last_position(position):
    """Set the last position in the file."""
    try:
        with open('last_position.txt', 'w') as f:
            f.write(str(position))
    except Exception as e:
        logging.error("Error writing last_position.txt: %s", e)

def append_filenames_to_input():
    """Prompt the user to input filenames and priorities."""
    logging.info("Enter filenames to download with priority (e.g., File1.zip CRITICAL), separated by commas (,): ")
    input_entries = input().split(',')
    with open('input.txt', 'a') as f:
        for entry in input_entries:
            entry = entry.strip()
            f.write(entry + '\n')

def read_filenames_from_input():
    """Read filenames and priorities from the input file."""
    input_file_entries = []
    if os.path.exists('input.txt'):
        with open('input.txt', 'r') as f:
            for line in f.readlines():
                parts = line.strip().split()
                if len(parts) == 2:
                    input_file_entries.append(parts)
                else:
                    logging.warning(f"Invalid entry in input file: {line.strip()}")
    return input_file_entries

def create_output_directory():
    """Create the output directory if it does not exist."""
    if not os.path.exists('output'):
        os.makedirs('output')
    logging.info("Output directory is located at: %s", os.path.abspath('output'))

def request_file_list(s):
    """Request the list of files from the server."""
    logging.info("Requesting file list...")
    s.sendall("LIST".encode('utf-8'))
    try:
        data = s.recv(BUFFER_SIZE)
        data = data.decode('utf-8')
        files = json.loads(data)
        logging.info("Available files:")
        for file, size in files.items():
            logging.info("%s: %s MB", file, size)
        return files
    except (ValueError, json.JSONDecodeError) as e:
        logging.error("Failed to decode the file list: %s", e)
        return {}
    except Exception as e:
        logging.error("Error while requesting file list: %s", e)
        return {}

def download_chunk(s, filename, priority, offset):
    """Download a chunk of the file from the server."""
    request = f"{filename} {priority} {offset}"
    s.sendall(request.encode('utf-8'))
    file_path = os.path.join('output', filename)
    speed_multiplier = SPEED_MULTIPLIERS.get(priority, 1)

    try:
        data = s.recv(BUFFER_SIZE * speed_multiplier)
        if data == b'EOF':
            return True  # File download is complete
        elif data:
            with open(file_path, 'ab') as f:
                f.write(data)
            return len(data)
        else:
            return 0
    except socket.error as e:
        logging.error("Error while downloading %s: %s", filename, e)
        if os.path.exists(file_path):
            os.remove(file_path)
        return 0
    except IOError as e:
        logging.error("Error while downloading %s: %s", filename, e)
        if os.path.exists(file_path):
            os.remove(file_path)
        return 0

class DownloadThread(threading.Thread):
    def __init__(self, s, filename, priority, file_size, progress, index):
        super().__init__()
        self.s = s
        self.filename = filename
        self.priority = priority
        self.file_size = file_size
        self.offset = 0
        self.done = threading.Event()
        self.progress = progress
        self.index = index

    def run(self):
        file_path = os.path.join('output', self.filename)
        open(file_path, 'wb').close()  # Overwrite the file if it exists

        while not self.done.is_set():
            chunk_size = download_chunk(self.s, self.filename, self.priority, self.offset)
            if chunk_size:
                self.offset += chunk_size
                percent_complete = (self.offset / self.file_size) * 100
                self.progress[self.index] = f"Downloading {self.filename} .... {percent_complete:.2f}%"
                self.print_progress()
                if self.offset >= self.file_size:
                    self.done.set()
            else:
                self.done.set()

    def print_progress(self):
        """Print the progress of all downloads."""
        sys.stdout.write("\033[H\033[J")  # Clear the console
        for progress in self.progress:
            sys.stdout.write(progress + "\n")
        sys.stdout.flush()

def start_client():
    """Start the client to download files from the server."""
    # Ensure last_position.txt exists
    if not os.path.exists('last_position.txt'):
        set_last_position(0)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((HOST, PORT))
            files = request_file_list(s)
            if not files:
                logging.info("No files available for download.")
                return

            create_output_directory()
            last_position = get_last_position()
            append_filenames_to_input()
            input_file_entries = read_filenames_from_input()[last_position:]
            download_threads = []
            progress = ["Downloading " + entry[0] + " .... 0.00%" for entry in input_file_entries]  # Initialize progress

            for index, (filename, priority) in enumerate(input_file_entries):
                filename = filename.strip()
                priority = priority.strip()
                file_size = files.get(filename, 0) * 1024 * 1024  # Convert MB to bytes

                if file_size == 0:
                    logging.error("File size for %s is zero or file does not exist on the server.", filename)
                    continue

                thread = DownloadThread(s, filename, priority, file_size, progress, index)
                thread.start()
                download_threads.append(thread)

            for thread in download_threads:
                thread.join()

            logging.info("All downloads completed.")
            set_last_position(last_position + len(input_file_entries))
        except socket.error as e:
            logging.error("Socket error: %s", e)
        except Exception as e:
            logging.error("Unexpected error: %s", e)

if __name__ == "__main__":
    start_client()
